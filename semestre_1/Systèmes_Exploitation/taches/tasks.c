
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>

#include "tasks.h"

typedef struct {
  func_t f;
  void *arg;
  task_type_t type;
} task_t;

/////////////////////////// QUEUE //////////////////////////////
#define MAX_QUEUE 10
typedef task_t queue_t[MAX_QUEUE];

static queue_t queue;
static unsigned get_index = 0, put_index = 0, queue_size = 0;

static int __push (const task_t *t)
{
  if (queue_size >= MAX_QUEUE)
    return -1;
  
  queue[put_index] = *t;
  put_index = (put_index + 1) % MAX_QUEUE;
  queue_size++;

  return 0;
}

static int __pop (task_t *t)
{
  if (queue_size == 0)
    return -1;

  *t = queue[get_index];
  get_index = (get_index + 1) % MAX_QUEUE;
  queue_size--;

  return 0;
}

static unsigned __size (void)
{
  return queue_size;
}

////////////////////////////////////////////////////////////////

pthread_mutex_t mutex, mutex_ex; 
pthread_cond_t cond_push, cond_pop, cond_end;
unsigned ongoing = 0;

static int push (const task_t *t)
{
  pthread_mutex_lock (&mutex);
  
  while (__size() == MAX_QUEUE)
    pthread_cond_wait (&cond_push, &mutex);

  assert (__push (t) != -1);

  pthread_cond_signal (&cond_pop);

  pthread_mutex_unlock (&mutex);

  return 0;
}

static int pop (task_t *t)
{
  pthread_mutex_lock (&mutex);

  while (__size() == 0)
    pthread_cond_wait (&cond_pop, &mutex);

  assert(__pop (t) != -1);
  ongoing++;

  pthread_cond_signal (&cond_push);

  pthread_mutex_unlock (&mutex);

  return 0;
}

static void task_terminated (task_t *t)
{
  pthread_mutex_lock (&mutex);

  ongoing--;
  if (ongoing + __size() == 0)
    pthread_cond_signal (&cond_end);

  pthread_mutex_unlock (&mutex);
}

static void pop_and_execute (void)
{
  task_t t;

  if (pop (&t) == 0) {
    if (t.type == EXCLUSIVE)
      pthread_mutex_lock (&mutex_ex);

    t.f (t.arg);

    if (t.type == EXCLUSIVE)
      pthread_mutex_unlock (&mutex_ex);

    task_terminated (&t);
  }
}

void tasks_submit (func_t f, void *arg, task_type_t type)
{
  task_t t = { f, arg, type };
  while (push (&t) == -1) ;
}

void tasks_wait_all (void)
{
  pthread_mutex_lock (&mutex);

  while (ongoing + __size() > 0)
    pthread_cond_wait (&cond_end, &mutex);

  pthread_mutex_unlock (&mutex);
}

void *thread_func (void *arg)
{
  int me = (int)(intptr_t)arg;
  printf ("Worker %d started\n", me);

  for (;;)
    pop_and_execute ();

  return NULL;
}

void tasks_init (int nbthreads)
{
  pthread_mutex_init (&mutex, NULL);
  pthread_mutex_init (&mutex_ex, NULL);
  pthread_cond_init( &cond_pop, NULL);
  pthread_cond_init( &cond_push, NULL);
  pthread_cond_init( &cond_end, NULL);

  pthread_t pid[nbthreads];

  for (int i = 0; i < nbthreads; i++)
    pthread_create (pid + i, NULL, thread_func, (void *)(intptr_t)i);
}

